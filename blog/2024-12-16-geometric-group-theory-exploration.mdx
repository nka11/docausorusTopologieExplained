---
slug: geometric-group-theory-exploration
title: 'G√©om√©trie des Groupes : Explorer l''Espace des Sym√©tries'
authors: [dr_geometrie]
tags: [groupes, g√©om√©trie, sym√©tries, topologie]
---


<div className="math-container">

## üé≠ La Danse des Sym√©tries

La **g√©om√©trie des groupes** r√©v√®le comment les structures alg√©briques s'incarnent dans l'espace g√©om√©trique. Cette discipline fascinante nous permet de visualiser les groupes comme des espaces m√©triques et de comprendre leurs propri√©t√©s √† travers la g√©om√©trie.

</div>

{/* truncate */}

## üéØ Groupes et Espaces M√©triques

Un **groupe** $(G, \cdot)$ est un ensemble muni d'une op√©ration binaire satisfaisant :
- **Associativit√©** : $(a \cdot b) \cdot c = a \cdot (b \cdot c)$
- **√âl√©ment neutre** : $\exists e \in G : e \cdot a = a \cdot e = a$
- **Inverses** : $\forall a \in G, \exists a^{-1} : a \cdot a^{-1} = e$

### Espace de Cayley

L'**espace de Cayley** d'un groupe est un graphe o√π :
- Les **sommets** repr√©sentent les √©l√©ments du groupe
- Les **ar√™tes** connectent les √©l√©ments qui diff√®rent par un g√©n√©rateur

## üîç Visualisation des Groupes Finis

```python
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from matplotlib.patches import Circle
import matplotlib.patches as patches

def visualize_finite_group(group_elements, group_operation, group_name):
    """Visualise un groupe fini via son graphe de Cayley"""
    
    # Construction du graphe de Cayley
    G = nx.DiGraph()
    
    # Ajout des sommets
    for element in group_elements:
        G.add_node(element)
    
    # Ajout des ar√™tes (multiplication par les g√©n√©rateurs)
    generators = find_generators(group_elements, group_operation)
    
    for element in group_elements:
        for generator in generators:
            result = group_operation(element, generator)
            G.add_edge(element, result, label=str(generator))
    
    # Visualisation
    plt.figure(figsize=(12, 8))
    
    # Positionnement des n≈ìuds
    if len(group_elements) <= 8:
        pos = nx.spring_layout(G, k=3, iterations=50)
    else:
        pos = nx.circular_layout(G)
    
    # Trac√© du graphe
    nx.draw_networkx_nodes(G, pos, node_color='lightblue', 
                          node_size=1000, alpha=0.8)
    nx.draw_networkx_edges(G, pos, edge_color='gray', 
                          arrows=True, arrowsize=20, alpha=0.6)
    nx.draw_networkx_labels(G, pos, font_size=10, font_weight='bold')
    
    # L√©gende des g√©n√©rateurs
    plt.title(f'Graphe de Cayley du Groupe {group_name}')
    plt.axis('off')
    
    # Informations sur le groupe
    plt.figtext(0.02, 0.02, f'Ordre: {len(group_elements)} | G√©n√©rateurs: {generators}', 
                fontsize=10, bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgray"))
    
    plt.tight_layout()
    plt.show()
    
    return G, generators

# Exemple : Groupe cyclique Z‚ÇÑ
def cyclic_group_operation(a, b):
    """Op√©ration du groupe cyclique Z‚ÇÑ"""
    return (a + b) % 4

z4_elements = [0, 1, 2, 3]
G_z4, generators_z4 = visualize_finite_group(z4_elements, cyclic_group_operation, "Z‚ÇÑ")

# Exemple : Groupe sym√©trique S‚ÇÉ
def symmetric_group_operation(perm1, perm2):
    """Composition de permutations"""
    result = [0] * len(perm1)
    for i in range(len(perm1)):
        result[i] = perm1[perm2[i]]
    return tuple(result)

s3_elements = [
    (0, 1, 2), (0, 2, 1), (1, 0, 2),
    (1, 2, 0), (2, 0, 1), (2, 1, 0)
]

G_s3, generators_s3 = visualize_finite_group(s3_elements, symmetric_group_operation, "S‚ÇÉ")
```

## üåü Groupes de Lie et Vari√©t√©s

Les **groupes de Lie** sont des groupes qui sont aussi des vari√©t√©s diff√©rentiables. Ils jouent un r√¥le central en physique et en g√©om√©trie.

### Visualisation du Groupe SO(3)

```python
def visualize_so3_group():
    """Visualise le groupe SO(3) des rotations 3D"""
    
    fig = plt.figure(figsize=(15, 5))
    
    # 1. Sph√®re des rotations
    ax1 = fig.add_subplot(1, 3, 1, projection='3d')
    
    # G√©n√©ration de rotations al√©atoires
    n_rotations = 100
    rotations = []
    
    for _ in range(n_rotations):
        # G√©n√©ration d'une rotation al√©atoire via quaternions
        q = np.random.randn(4)
        q = q / np.linalg.norm(q)
        
        # Conversion quaternion -> matrice de rotation
        w, x, y, z = q
        R = np.array([
            [1-2*(y**2+z**2), 2*(x*y-w*z), 2*(x*z+w*y)],
            [2*(x*y+w*z), 1-2*(x**2+z**2), 2*(y*z-w*x)],
            [2*(x*z-w*y), 2*(y*z+w*x), 1-2*(x**2+y**2)]
        ])
        rotations.append(R)
    
    # Visualisation des axes de rotation
    for R in rotations[:20]:  # Afficher seulement les 20 premi√®res
        # L'axe de rotation est l'axe propre avec valeur propre 1
        eigenvals, eigenvecs = np.linalg.eig(R)
        axis_idx = np.argmin(np.abs(eigenvals - 1))
        axis = np.real(eigenvecs[:, axis_idx])
        
        # Tracer l'axe de rotation
        ax1.plot([0, axis[0]], [0, axis[1]], [0, axis[2]], 'b-', alpha=0.6)
    
    ax1.set_title('Groupe SO(3) : Axes de Rotation')
    ax1.set_xlabel('X')
    ax1.set_ylabel('Y')
    ax1.set_zlabel('Z')
    
    # 2. Vari√©t√© des rotations
    ax2 = fig.add_subplot(1, 3, 2, projection='3d')
    
    # Param√©trisation d'Euler
    alpha = np.linspace(0, 2*np.pi, 20)
    beta = np.linspace(0, np.pi, 10)
    
    for a in alpha[::4]:  # √âchantillonnage
        for b in beta[::2]:
            # Rotation d'Euler
            cos_a, sin_a = np.cos(a), np.sin(a)
            cos_b, sin_b = np.cos(b), np.sin(b)
            
            # Point sur la sph√®re
            x = sin_b * cos_a
            y = sin_b * sin_a
            z = cos_b
            
            ax2.scatter(x, y, z, c='red', alpha=0.7, s=20)
    
    ax2.set_title('Vari√©t√© SO(3) : Sph√®re des Rotations')
    ax2.set_xlabel('X')
    ax2.set_ylabel('Y')
    ax2.set_zlabel('Z')
    
    # 3. Alg√®bre de Lie so(3)
    ax3 = fig.add_subplot(1, 3, 3, projection='3d')
    
    # Matrices antisym√©triques 3x3
    so3_basis = [
        np.array([[0, 0, 0], [0, 0, -1], [0, 1, 0]]),  # J_x
        np.array([[0, 0, 1], [0, 0, 0], [-1, 0, 0]]),  # J_y
        np.array([[0, -1, 0], [1, 0, 0], [0, 0, 0]])   # J_z
    ]
    
    # Visualisation des g√©n√©rateurs
    colors = ['red', 'green', 'blue']
    labels = ['J_x', 'J_y', 'J_z']
    
    for i, (J, color, label) in enumerate(zip(so3_basis, colors, labels)):
        # Tracer la matrice comme un vecteur dans R^9
        vec = J.flatten()
        
        # Projection sur les 3 premi√®res dimensions
        ax3.quiver(0, 0, 0, vec[0], vec[1], vec[2], 
                  color=color, label=label, alpha=0.8)
    
    ax3.set_title('Alg√®bre de Lie so(3)')
    ax3.set_xlabel('X')
    ax3.set_ylabel('Y')
    ax3.set_zlabel('Z')
    ax3.legend()
    
    plt.tight_layout()
    plt.show()

visualize_so3_group()
```

## üî¨ Actions de Groupes et Orbites

Une **action de groupe** sur un ensemble $X$ est une application :
$$G \times X \to X : (g, x) \mapsto g \cdot x$$

### Visualisation des Orbites

```python
def visualize_group_actions():
    """Visualise diff√©rentes actions de groupes"""
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    
    # 1. Action de Z‚ÇÑ sur le cercle
    ax1 = axes[0, 0]
    
    theta = np.linspace(0, 2*np.pi, 100)
    x_circle = np.cos(theta)
    y_circle = np.sin(theta)
    
    ax1.plot(x_circle, y_circle, 'k-', alpha=0.3)
    
    # Points initiaux
    n_points = 8
    initial_angles = np.linspace(0, 2*np.pi, n_points, endpoint=False)
    
    colors = plt.cm.tab10(np.linspace(0, 1, n_points))
    
    for i, (angle, color) in enumerate(zip(initial_angles, colors)):
        x_init = np.cos(angle)
        y_init = np.sin(angle)
        
        # Orbite sous l'action de Z‚ÇÑ (rotation de œÄ/2)
        orbit_x = [x_init]
        orbit_y = [y_init]
        
        for k in range(1, 4):
            new_angle = angle + k * np.pi/2
            orbit_x.append(np.cos(new_angle))
            orbit_y.append(np.sin(new_angle))
        
        ax1.plot(orbit_x, orbit_y, 'o-', color=color, markersize=8, 
                label=f'Orbite {i+1}')
    
    ax1.set_title('Action de Z‚ÇÑ sur le Cercle')
    ax1.set_aspect('equal')
    ax1.grid(True, alpha=0.3)
    ax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    
    # 2. Action de SO(2) sur le plan
    ax2 = axes[0, 1]
    
    # Points dans le plan
    points = np.array([[2, 0], [1, 1], [0, 2], [-1, 1]])
    
    # Orbites sous rotation continue
    t = np.linspace(0, 2*np.pi, 100)
    
    for i, point in enumerate(points):
        orbit_x = []
        orbit_y = []
        
        for angle in t:
            R = np.array([[np.cos(angle), -np.sin(angle)],
                         [np.sin(angle), np.cos(angle)]])
            rotated_point = R @ point
            orbit_x.append(rotated_point[0])
            orbit_y.append(rotated_point[1])
        
        ax2.plot(orbit_x, orbit_y, '-', alpha=0.7, linewidth=2)
        ax2.plot(point[0], point[1], 'o', markersize=8, 
                color=plt.cm.tab10(i))
    
    ax2.set_title('Action de SO(2) sur le Plan')
    ax2.set_aspect('equal')
    ax2.grid(True, alpha=0.3)
    
    # 3. Action du groupe di√©dral D‚ÇÑ sur le carr√©
    ax3 = axes[1, 0]
    
    # Carr√©
    square = np.array([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]])
    
    # Transformations de D‚ÇÑ
    transformations = []
    
    # Rotations
    for k in range(4):
        angle = k * np.pi/2
        R = np.array([[np.cos(angle), -np.sin(angle)],
                     [np.sin(angle), np.cos(angle)]])
        transformations.append(R)
    
    # R√©flexions
    transformations.extend([
        np.array([[1, 0], [0, -1]]),   # R√©flexion selon x
        np.array([[-1, 0], [0, 1]]),   # R√©flexion selon y
        np.array([[0, 1], [1, 0]]),    # R√©flexion selon y=x
        np.array([[0, -1], [-1, 0]])   # R√©flexion selon y=-x
    ])
    
    # Application des transformations
    for i, T in enumerate(transformations):
        transformed_square = (T @ square.T).T
        ax3.plot(transformed_square[:, 0], transformed_square[:, 1], 
                '-', alpha=0.7, linewidth=2)
    
    ax3.set_title('Action du Groupe Di√©dral D‚ÇÑ')
    ax3.set_aspect('equal')
    ax3.grid(True, alpha=0.3)
    
    # 4. Espace quotient
    ax4 = axes[1, 1]
    
    # Torus comme quotient de R¬≤ par Z¬≤
    def plot_torus_quotient():
        # Grille dans R¬≤
        x = np.linspace(-2, 2, 20)
        y = np.linspace(-2, 2, 20)
        X, Y = np.meshgrid(x, y)
        
        # Identification des points √©quivalents
        X_quotient = X % 1
        Y_quotient = Y % 1
        
        # Visualisation du quotient
        ax4.scatter(X_quotient, Y_quotient, alpha=0.6, s=20)
        
        # Bordure du quotient [0,1] √ó [0,1]
        ax4.plot([0, 1, 1, 0, 0], [0, 0, 1, 1, 0], 'r-', linewidth=3)
        
        ax4.set_title('Espace Quotient R¬≤/Z¬≤ ‚âÖ T¬≤')
        ax4.set_xlim(-0.1, 1.1)
        ax4.set_ylim(-0.1, 1.1)
        ax4.set_aspect('equal')
        ax4.grid(True, alpha=0.3)
    
    plot_torus_quotient()
    
    plt.tight_layout()
    plt.show()

visualize_group_actions()
```

## üé® Applications en Topologie

```python
def topological_applications():
    """Applications de la g√©om√©trie des groupes en topologie"""
    
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    
    # 1. Rev√™tements universels
    ax1 = axes[0, 0]
    
    # Cercle et sa droite de rev√™tement
    t = np.linspace(0, 4*np.pi, 200)
    
    # Droite de rev√™tement
    ax1.plot(t, np.zeros_like(t), 'b-', linewidth=2, label='R (rev√™tement)')
    
    # Projection sur le cercle
    x_proj = np.cos(t)
    y_proj = np.sin(t)
    ax1.plot(x_proj, y_proj, 'r-', linewidth=3, label='S¬π (cercle)')
    
    # Fl√®ches de projection
    for i in range(0, len(t), 50):
        ax1.arrow(t[i], 0, x_proj[i] - t[i], y_proj[i], 
                 head_width=0.1, head_length=0.1, fc='gray', ec='gray', alpha=0.7)
    
    ax1.set_title('Rev√™tement Universel de S¬π')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # 2. Groupe fondamental
    ax2 = axes[0, 1]
    
    # Cercle avec lacets
    theta = np.linspace(0, 2*np.pi, 100)
    x_circle = np.cos(theta)
    y_circle = np.sin(theta)
    
    ax2.plot(x_circle, y_circle, 'k-', linewidth=3)
    
    # Lacets de diff√©rentes classes d'homotopie
    base_point = (1, 0)
    
    # Lacet trivial
    trivial_loop = np.array([base_point, base_point])
    ax2.plot(trivial_loop[:, 0], trivial_loop[:, 1], 'go-', 
            markersize=10, label='Lacet trivial')
    
    # Lacet simple
    simple_theta = np.linspace(0, 2*np.pi, 50)
    simple_loop_x = np.cos(simple_theta)
    simple_loop_y = np.sin(simple_theta)
    ax2.plot(simple_loop_x, simple_loop_y, 'b-', linewidth=2, 
            label='Lacet simple')
    
    # Lacet double
    double_theta = np.linspace(0, 4*np.pi, 100)
    double_loop_x = np.cos(double_theta)
    double_loop_y = np.sin(double_theta)
    ax2.plot(double_loop_x, double_loop_y, 'r--', linewidth=2, 
            label='Lacet double')
    
    ax2.plot(base_point[0], base_point[1], 'ko', markersize=12, 
            label='Point de base')
    
    ax2.set_title('Groupe Fondamental œÄ‚ÇÅ(S¬π) ‚âÖ Z')
    ax2.set_aspect('equal')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    
    # 3. Vari√©t√©s hyperboliques
    ax3 = axes[1, 0]
    
    # Mod√®le du disque de Poincar√©
    def poincare_distance(z1, z2):
        """Distance hyperbolique dans le disque de Poincar√©"""
        return np.arccosh(1 + 2 * abs(z1 - z2)**2 / ((1 - abs(z1)**2) * (1 - abs(z2)**2)))
    
    # G√©od√©siques dans le mod√®le de Poincar√©
    # G√©od√©siques passant par l'origine
    r = np.linspace(0, 0.9, 100)
    
    for angle in np.linspace(0, 2*np.pi, 8, endpoint=False):
        x_geo = r * np.cos(angle)
        y_geo = r * np.sin(angle)
        ax3.plot(x_geo, y_geo, 'b-', alpha=0.7)
    
    # Cercle limite
    circle_limit = plt.Circle((0, 0), 1, fill=False, color='black', linewidth=2)
    ax3.add_patch(circle_limit)
    
    ax3.set_xlim(-1.1, 1.1)
    ax3.set_ylim(-1.1, 1.1)
    ax3.set_aspect('equal')
    ax3.set_title('Mod√®le Hyperbolique du Disque de Poincar√©')
    ax3.grid(True, alpha=0.3)
    
    # 4. Groupes fuchsiens
    ax4 = axes[1, 1]
    
    # Action du groupe modulaire PSL(2,Z)
    def modular_transform(z, matrix):
        """Transformation de M√∂bius"""
        a, b, c, d = matrix
        return (a*z + b) / (c*z + d)
    
    # Transformation T: z ‚Üí z + 1
    def T_transform(z):
        return z + 1
    
    # Transformation S: z ‚Üí -1/z
    def S_transform(z):
        return -1/z
    
    # Visualisation dans le demi-plan sup√©rieur
    x = np.linspace(-3, 3, 200)
    y = np.linspace(0.1, 3, 100)
    X, Y = np.meshgrid(x, y)
    Z = X + 1j * Y
    
    # R√©gion fondamentale
    fundamental_region = []
    for i in range(len(x)):
        for j in range(len(y)):
            z = Z[j, i]
            if abs(z) >= 1 and abs(z.real) <= 0.5:
                fundamental_region.append([x[i], y[j]])
    
    if fundamental_region:
        fundamental_region = np.array(fundamental_region)
        ax4.scatter(fundamental_region[:, 0], fundamental_region[:, 1], 
                   alpha=0.6, s=1, c='blue')
    
    # Bordure de la r√©gion fondamentale
    theta = np.linspace(0, np.pi, 100)
    circle_x = np.cos(theta)
    circle_y = np.sin(theta)
    ax4.plot(circle_x, circle_y, 'r-', linewidth=2)
    
    ax4.axvline(x=-0.5, color='r', linewidth=2)
    ax4.axvline(x=0.5, color='r', linewidth=2)
    
    ax4.set_xlim(-2, 2)
    ax4.set_ylim(0, 2)
    ax4.set_title('R√©gion Fondamentale de PSL(2,Z)')
    ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

topological_applications()
```

## üìö Ressources Compl√©mentaires

- **Groupes de Lie** : [Groupes de Lie](/docs/theory/08_groupes_lie)
- **Alg√®bres de Lie** : [Alg√®bres de Lie](/docs/theory/09_algebres_lie)
- **Programme d'Erlangen** : [Programme d'Erlangen](/docs/theory/10_programme_erlangen)
- **Notebooks** : [Groupes et Alg√®bres](/docs/notebooks/02_groupes_lie_algebres)

## üéØ D√©fi Final

**Exercice** : Impl√©mentez un visualiseur interactif pour les groupes de Lie classiques.

```python
def interactive_lie_group_visualizer():
    """
    D√©fi : Cr√©er un visualiseur interactif pour les groupes de Lie
    
    Fonctionnalit√©s :
    1. S√©lection du groupe (SO(3), SU(2), SL(2,R), etc.)
    2. Visualisation de la vari√©t√© du groupe
    3. Action du groupe sur diff√©rents espaces
    4. Alg√®bre de Lie et g√©n√©rateurs
    5. Sous-groupes et orbites
    """
    
    def visualize_so3_interactive():
        """Visualiseur interactif pour SO(3)"""
        
        fig = plt.figure(figsize=(15, 10))
        
        # Interface de contr√¥le
        ax_control = plt.subplot2grid((2, 3), (0, 0), colspan=3)
        ax_control.axis('off')
        ax_control.set_title('Contr√¥les pour SO(3)', fontsize=14, fontweight='bold')
        
        # Sliders pour les angles d'Euler
        ax_control.text(0.1, 0.8, 'Angle Œ± (rotation autour de z):', fontsize=12)
        ax_control.text(0.1, 0.6, 'Angle Œ≤ (rotation autour de x):', fontsize=12)
        ax_control.text(0.1, 0.4, 'Angle Œ≥ (rotation autour de z):', fontsize=12)
        
        # Visualisation 3D
        ax_3d = plt.subplot2grid((2, 3), (1, 0), projection='3d')
        
        # Cube de r√©f√©rence
        def draw_cube(ax, size=1, alpha=0.3):
            """Dessine un cube de r√©f√©rence"""
            # Vertices du cube
            vertices = np.array([
                [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
                [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
            ]) * size / 2
            
            # Faces du cube
            faces = [
                [0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 5, 4],
                [2, 3, 7, 6], [0, 3, 7, 4], [1, 2, 6, 5]
            ]
            
            for face in faces:
                square = vertices[face]
                ax.plot_trisurf(square[:, 0], square[:, 1], square[:, 2], 
                              alpha=alpha, color='lightblue')
        
        # Rotation d'Euler
        def euler_rotation_matrix(alpha, beta, gamma):
            """Matrice de rotation d'Euler ZXZ"""
            R_alpha = np.array([
                [np.cos(alpha), -np.sin(alpha), 0],
                [np.sin(alpha), np.cos(alpha), 0],
                [0, 0, 1]
            ])
            
            R_beta = np.array([
                [1, 0, 0],
                [0, np.cos(beta), -np.sin(beta)],
                [0, np.sin(beta), np.cos(beta)]
            ])
            
            R_gamma = np.array([
                [np.cos(gamma), -np.sin(gamma), 0],
                [np.sin(gamma), np.cos(gamma), 0],
                [0, 0, 1]
            ])
            
            return R_gamma @ R_beta @ R_alpha
        
        # Animation de la rotation
        angles = np.linspace(0, 2*np.pi, 50)
        
        for i, angle in enumerate(angles):
            ax_3d.clear()
            
            # Rotation progressive
            R = euler_rotation_matrix(angle, angle/2, angle/3)
            
            # Cube transform√©
            cube_vertices = np.array([
                [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
                [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
            ])
            
            transformed_cube = (R @ cube_vertices.T).T
            
            # Dessiner le cube transform√©
            draw_cube(ax_3d, size=2, alpha=0.7)
            
            # Axes de rotation
            axes_original = np.eye(3)
            axes_rotated = (R @ axes_original.T).T
            
            colors = ['red', 'green', 'blue']
            labels = ['X', 'Y', 'Z']
            
            for axis, color, label in zip(axes_rotated, colors, labels):
                ax_3d.quiver(0, 0, 0, axis[0], axis[1], axis[2], 
                           color=color, arrow_length_ratio=0.1, linewidth=3)
                ax_3d.text(axis[0], axis[1], axis[2], label, fontsize=12)
            
            ax_3d.set_xlim(-2, 2)
            ax_3d.set_ylim(-2, 2)
            ax_3d.set_zlim(-2, 2)
            ax_3d.set_title(f'Rotation SO(3) - t = {i+1}/50')
        
        # Alg√®bre de Lie
        ax_lie = plt.subplot2grid((2, 3), (1, 1))
        
        # G√©n√©rateurs de so(3)
        J_x = np.array([[0, 0, 0], [0, 0, -1], [0, 1, 0]])
        J_y = np.array([[0, 0, 1], [0, 0, 0], [-1, 0, 0]])
        J_z = np.array([[0, -1, 0], [1, 0, 0], [0, 0, 0]])
        
        generators = [J_x, J_y, J_z]
        names = ['J_x', 'J_y', 'J_z']
        
        # Visualisation des g√©n√©rateurs
        for i, (J, name) in enumerate(zip(generators, names)):
            # Tracer la matrice comme une image
            im = ax_lie.imshow(J, cmap='RdBu', aspect='equal')
            ax_lie.set_title(f'G√©n√©rateur {name}')
            plt.colorbar(im, ax=ax_lie)
        
        # Relations de commutation
        ax_comm = plt.subplot2grid((2, 3), (1, 2))
        ax_comm.axis('off')
        
        commutation_relations = [
            '[J_x, J_y] = iJ_z',
            '[J_y, J_z] = iJ_x',
            '[J_z, J_x] = iJ_y'
        ]
        
        ax_comm.text(0.1, 0.8, 'Relations de Commutation:', fontsize=14, fontweight='bold')
        for i, relation in enumerate(commutation_relations):
            ax_comm.text(0.1, 0.6 - i*0.2, relation, fontsize=12, 
                        bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgray"))
        
        plt.tight_layout()
        plt.show()
    
    # Ex√©cution du visualiseur
    visualize_so3_interactive()

# Ex√©cution du d√©fi
interactive_lie_group_visualizer()
```

---

*La g√©om√©trie des groupes r√©v√®le la beaut√© cach√©e des structures alg√©briques. En visualisant les groupes comme des espaces g√©om√©triques, nous d√©couvrons les sym√©tries profondes qui gouvernent notre univers math√©matique.*
